<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sPathFinder</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//PathingSpeed = 5;
OriginalPathingSpeed = 160/room_speed; //for 160, 5 blocks/sec
path_speed = OriginalPathingSpeed;
XCOA = 0;
YCOA = 90;
OldX = x;
OldY = y;

//Draw/Rotation Correction
ObjectSideLength = 32;
Radius = .707*ObjectSideLength; //sqrt(2)/2
OriginalXOfCenterPoint = ObjectSideLength/2; //Radius*cos(-45)
OriginalYOfCenterPoint = -ObjectSideLength/2; //Radius*sin(-45);
XChange = 0;
YChange = 0;


WiggleAmplitude = 0;
WigglePeriod = room_speed/10;
WiggleTime = 0;
TrailTime = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if(mouse_check_button_pressed(mb_any)){

//if we collide with terror, move away randomly

DestinationX = random(room_width)
DestinationY = random(room_height)
var DestinationBlockX=DestinationX div oAStar.blockSize; //translate into nodes / blocks
var DestinationBlockY=DestinationY div oAStar.blockSize;

if(instance_place(x,y,oLightTerror)){
    //while the end of our path is an unwalkable block / node
    while (oAStar.walkable[DestinationBlockX,DestinationBlockY]==false){
        DestinationX = random(room_width) //reset destination
        DestinationY = random(room_height)
        var DestinationBlockX=DestinationX div oAStar.blockSize;
        var DestinationBlockY=DestinationY div oAStar.blockSize;
    }
    var path=aStarGetPath(x,y,DestinationX,DestinationY);
    path_start(path,OriginalPathingSpeed,0,true);
}
//Determine if we are impeded by friction for our path
if place_meeting(x,y,oFrictionBlock){
    getPathingSpeed(); 
} else{
    getPathingSpeed();
} // LOL
  
  
//obtaining hspeed and vspeed for instance on path

MyHSpeed = x - OldX;
MyVSpeed = y - OldY;
OldX = x;
OldY = y;

//Facing
//Determine x and y components of angle
if MyHSpeed &lt; 0 {XCOA = 180}
if MyHSpeed &gt; 0 {XCOA = 0}
if MyVSpeed &lt; 0 {YCOA = 90}
if MyVSpeed &gt; 0 {YCOA = 270}

//Determine if cardinal or diagonal
if MyVSpeed  == 0 {
    Facing = XCOA;
}else{
    if MyHSpeed == 0 {
        Facing = YCOA;
    }else{
        if (XCOA==0 &amp;&amp; YCOA==270){
            XCOA = 360;
        }
        Facing = mean(XCOA,YCOA);
    }
}

//X and Y coordinate corrections to Facing due to rotations about 0,0 on sprite instead of center
switch (Facing)
    {
    case 0:
        XChange = 0;
        YChange = 0;
        break;
    case 45:
        XChange = (1-.707)*Radius;
        YChange = ObjectSideLength/2;
        break;
    case 90:
        XChange = 0;
        YChange = ObjectSideLength;
        break;
    case 135:
        XChange = -ObjectSideLength/2;
        YChange = (1+.707)*Radius;
        break;
    case 180:
        XChange = -ObjectSideLength;
        YChange = ObjectSideLength;
        break;
    case 225:
        XChange = -Radius*(1+.707);
        YChange = ObjectSideLength/2;
        break;
    case 270:
        XChange = -ObjectSideLength;
        YChange = 0;
        break;
    case 315:
        XChange = -ObjectSideLength/2;
        YChange = (-1+.707)*Radius;
        break;

    }

    XCorrection = -XChange; //Move image in the opposite direction of unintentional shift
    YCorrection = YChange; // positive y is downward but did calculations with it upward
    
//Wiggling
if ObjectMoving(){ //Only while moving
    if (WiggleTime mod WigglePeriod == 0){
        WiggleAmplitude = random_range(-15,15)
        WiggleTime = 0;
    } else {
        WiggleAmplitude = 0;
    }
    WiggleTime = WiggleTime+1;
}

//Bubbles

 var BubbleSize = 32;
TrailInterval = BubbleSize div path_speed;

if TrailTime == TrailInterval {
    instance_create(x,y,oBubbles)
    TrailTime = 0;
    }
TrailTime = TrailTime + 1;

//DID NOT WORK :'(    
//XCorrection = -1*(Radius*cos(Facing - 45) - OriginalXOfCenterPoint); //draw it from the centerpoint at original angle 45
//YCorrection = Radius*sin(Facing - 45) - OriginalYOfCenterPoint; //positive y downward
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//If we don't want the color path to show up in game, have debug var

if oGame.debugging {
    //draw path elements
    if(path_get_number(path_index)&gt;=2){
        //draw path
        draw_set_color(c_blue);
        for(var i=0;i&lt;path_get_number(path_index)-1;i++){
            draw_line(
                path_get_point_x(path_index,i)+.5*oAStar.blockSize,
                path_get_point_y(path_index,i)+.5*oAStar.blockSize,
                path_get_point_x(path_index,i+1)+.5*oAStar.blockSize,
                path_get_point_y(path_index,i+1)+.5*oAStar.blockSize
            );
        }
        //draw starting and ending point
        draw_set_color(c_green);
        draw_circle(path_get_point_x(path_index,0)+.5*oAStar.blockSize,
            path_get_point_y(path_index,0)+.5*oAStar.blockSize,5,false);
        draw_set_color(c_red);
        draw_circle(path_get_point_x(path_index,path_get_number(path_index)-1)+.5*oAStar.blockSize,
            path_get_point_y(path_index,path_get_number(path_index)-1)+.5*oAStar.blockSize,5,false);
            
    }
}

//List speed for debugging
if oGame.debugging {
    draw_set_color(c_black);
    draw_text(x+32,y+48, string(MyHSpeed));
    draw_text(x-48,y-16, string(MyVSpeed));
    draw_set_color(c_green);
    draw_text(x+48,y+16, string(Facing));
    //draw_text(x+32,y-16, string(YCorrection));
}

//draw_sprite(sprite_index,image_index,x,y)

//Draw our sprite normally, but facing our 'Facing' direction, without changing the image_angle, so as not to affect collision

draw_sprite_ext(sprite_index,image_index,x + XCorrection,y + YCorrection,image_xscale,image_yscale,Facing + WiggleAmplitude,image_blend,image_alpha)
//draw_self(); //AFTER PATH COMPLETE!!!
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
